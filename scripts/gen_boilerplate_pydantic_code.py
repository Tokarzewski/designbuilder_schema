from xmlschema import XMLSchema
from pathlib import Path


def get_python_type(xsd_type: str) -> str:
    if not xsd_type:
        return "Any"
    type_mapping = {
        "string": "str",
        "decimal": "float",
        "integer": "int",
        "boolean": "bool",
        "date": "datetime.date",
        "dateTime": "datetime.datetime",
        "time": "datetime.time",
        "float": "float",
        "double": "float",
        "long": "int",
        "int": "int",
        "unsignedByte": "int",
        "byte": "int",
        "unsignedShort": "int",
        "unsignedInt": "int",
        "anyType": "Any",
    }
    xsd_type = xsd_type.replace("{http://www.w3.org/2001/XMLSchema}", "")
    return type_mapping.get(xsd_type, "str")


def get_all_complex_elements(db_xsd):
    dict = {"dbXML": db_xsd}

    def update_one_level(dict):
        temp_dict = {}
        for element in dict.values():
            child_elements = element.findall("*")
            for child in child_elements:
                temp_dict[child.tag] = child
        dict.update(temp_dict)

    # update elements
    for _ in range(20):
        update_one_level(dict)

    dict.pop("")

    return dict.values()


def generate_class(element) -> dict:
    fields = []
    if hasattr(element.type, "attributes"):
        for attr_name, attr in element.type.attributes.items():
            if attr_name != None:
                python_type = get_python_type(attr.type.name)
                fields.append(f"    {attr_name}: {python_type}")

        for child_element in element.findall("*"):
            if child_element.type != None:
                if child_element.type.has_simple_content():
                    python_type = get_python_type(child_element.type.name)
                    fields.append(f"    {child_element.tag}: {python_type}")
                else:
                    fields.append(f"    {child_element.tag}: '{child_element.tag}'")

    return {
        element.tag: "\n".join(
            [
                f"class {element.tag}(BaseModel):",
                *(fields if fields else ["    pass"]),
                "",
            ]
        )
    }


def convert_xsd_to_pydantic(db_xsd_path: str, output_path: str) -> None:

    # Process all elements starting from root
    db_xsd = XMLSchema(db_xsd_path)
    processed_classes = {}
    for complex_elem in get_all_complex_elements(db_xsd):
        processed_classes.update(generate_class(complex_elem))

    # Generate file content
    content = "\n".join(
        [
            "from pydantic import BaseModel",
            "from typing import Optional, List, Any",
            "import datetime",
            "",
            *processed_classes.values(),
        ]
    )
    # Format if black is available
    try:
        import black

        content = black.format_str(content, mode=black.FileMode())
    except ImportError:
        pass

    Path(output_path).write_text(content)


if __name__ == "__main__":
    convert_xsd_to_pydantic("scripts/DesignBuilder.xsd", "scripts/autogenerated.py")
